{"version":3,"sources":["../../src/schema/fields/fields.ts","../../src/schema/table/types.ts","../../src/pg/index.ts","../../src/pg/pg.ts","../../src/utils/utils.ts","../../src/pg/sqrl.ts","../../src/schema/codegen/utils.ts","../../src/schema/codegen/table.ts","../../src/schema/cicd/deployer/utils.ts","../../src/schema/cicd/deployer/deployer.ts","../../src/schema/codegen/schema.ts"],"sourcesContent":["import type { Field, CustomField, FieldOptions } from \"./types\";\n\nexport const SQL = <T>(sql:string) : CustomField<T> => ({type: '$', statement: sql})\n\n/**\n * @description\n * - Auto-incrementing integer primary key\n */\nexport const PK_AUTO_INT = (options?:FieldOptions<number,false>):Field<number,false> => ({\n    type: 'INTEGER',\n    options: {\n        ...options,\n        generatedAlwaysAsIdentity: true,\n        primaryKey: true,\n    }\n});\n\n/**\n * @description\n * - Auto-incrementing UUID primary key\n */\nexport const PK_AUTO_UUID = (options?:FieldOptions<string,false>):Field<string,false> => ({\n    type: 'UUID',\n    options: {\n        ...options,\n        primaryKey: true,\n        default: 'gen_random_uuid()',\n    }\n});\n\n/**\n * @description\n * - UUID\n */\nexport const UUID = <N extends boolean, A extends boolean = false>(options?:FieldOptions<string,N,A>):Field<string,N,A> => ({\n    type: 'UUID',\n    options\n});\n\n/**\n * @description\n * - Integer\n */\nexport const INTEGER = <N extends boolean, A extends boolean = false>(options?:FieldOptions<number,N,A>):Field<number,N,A> => <const>({\n    type: 'INTEGER',\n    options\n});\n\n/**\n * @description\n * - VARCHAR\n */\nexport const VARCHAR = <N extends boolean, A extends boolean = false>(value:number, options?:FieldOptions<string,N,A>):Field<string,N,A> => ({\n    type: 'VARCHAR',\n    argument: value,\n    options\n});\n\n/**\n * @description\n * - SERIAL\n */\nexport const SERIAL = <N extends boolean, A extends boolean = false>(options?:FieldOptions<number,N,A>):Field<number,N,A> => ({\n    type: 'SERIAL',\n    options\n});\n\n/**\n * @description\n * - TEXT\n */\nexport const TEXT = <N extends boolean, A extends boolean = false>(options?:FieldOptions<string,N,A>):Field<string,N,A> => ({\n    type: 'TEXT',\n    options\n});\n\n/**\n * @description\n * - BOOLEAN\n */\nexport const BOOLEAN = <N extends boolean, A extends boolean = false>(options?:FieldOptions<boolean,N,A>):Field<boolean,N,A> => ({\n    type: 'BOOLEAN',\n    options\n});\n\n/**\n * @description\n * - TIMESTAMP\n */\nexport const TIMESTAMP = <N extends boolean, A extends boolean = false>(options?:FieldOptions<string,N,A>):Field<string,N,A> => ({\n    type: 'TIMESTAMP',\n    options\n});\n\n/**\n * @description\n * - ENUM\n */\nexport const ENUM = <T extends readonly string[], N extends boolean = false>(value:T, options?:FieldOptions<T[number],N>) => ({\n    type: 'ENUM',\n    argument: value,\n    options\n});\n\n/**\n * @description\n * - JSONB\n */\nexport const JSONB = <T extends Record<any,any>, N extends boolean = false>(options?:FieldOptions<T,N,false>):Field<T,N,false> => ({\n    type: 'JSONB',\n    options\n});\n","import { FieldSchema } from \"../../pg/types\";\nimport { CustomField, type Field } from \"../fields\"\nexport type TableInput = Record<string, Field<any, any, any> | CustomField<any>>\nexport type Table<\n  T extends TableInput = TableInput\n> = T\n\nexport class TableMap extends Map<string, Field<any, any, any>> {\n  constructor(tableMap: TableMap) {\n    super(tableMap);\n  }\n}\n\nexport class PostgresTableMap extends Map<string, FieldSchema> {\n  constructor(tableMap:PostgresTableMap){\n    super(tableMap)\n  }\n}","import * as dotenv from 'dotenv';\n\ndotenv.config();\n\nexport * from './pg';\nexport * from './sqrl';","// import { Client as PgClient } from \"pg\";\nimport pg from 'pg';\n\nexport const PgClient = pg.Client;\n\nexport type PgClientParams = ConstructorParameters<typeof PgClient>[0];\n\n/**\n * \n * @param params \n * ```typescript\n * string | {\n *   user?: string, // default process.env.PGUSER || process.env.USER\n *   password?: string or function, //default process.env.PGPASSWORD\n *   host?: string, // default process.env.PGHOST\n *   port?: number, // default process.env.PGPORT\n *   database?: string, // default process.env.PGDATABASE || user\n *   connectionString?: string, // e.g. postgres://user:password@host:5432/database\n *   ssl?: any, // passed directly to node.TLSSocket, supports all tls.connect options\n *   types?: any, // custom type parsers\n *   statement_timeout?: number, // number of milliseconds before a statement in query will time out, default is no timeout\n *   query_timeout?: number, // number of milliseconds before a query call will timeout, default is no timeout\n *   lock_timeout?: number, // number of milliseconds a query is allowed to be en lock state before it's cancelled due to lock timeout\n *   application_name?: string, // The name of the application that created this Client instance\n *   connectionTimeoutMillis?: number, // number of milliseconds to wait for connection, default is no timeout\n *   idle_in_transaction_session_timeout?: number // number of milliseconds before terminating any session with an open idle transaction, default is no timeout\n * }\n * ```\n * @returns \n */\nexport const createPgClient = (params: PgClientParams) => {\n  return new PgClient(params);\n}\n\n/**\n * \n * @param params \n * ```typescript\n * {\n *   user?: string, // default process.env.PGUSER || process.env.USER\n *   password?: string or function, //default process.env.PGPASSWORD\n *   host?: string, // default process.env.PGHOST\n *   port?: number, // default process.env.PGPORT\n *   database?: string, // default process.env.PGDATABASE || user\n *   connectionString?: string, // e.g. postgres://user:password@host:5432/database\n *   ssl?: any, // passed directly to node.TLSSocket, supports all tls.connect options\n *   types?: any, // custom type parsers\n *   statement_timeout?: number, // number of milliseconds before a statement in query will time out, default is no timeout\n *   query_timeout?: number, // number of milliseconds before a query call will timeout, default is no timeout\n *   lock_timeout?: number, // number of milliseconds a query is allowed to be en lock state before it's cancelled due to lock timeout\n *   application_name?: string, // The name of the application that created this Client instance\n *   connectionTimeoutMillis?: number, // number of milliseconds to wait for connection, default is no timeout\n *   idle_in_transaction_session_timeout?: number // number of milliseconds before terminating any session with an open idle transaction, default is no timeout\n * }\n * ```\n * @returns \n */\nexport const createConnectedPgClient = async (params: ConstructorParameters<typeof PgClient>[0]) => {\n  const client = createPgClient(params);\n  await client.connect();\n  return client;\n}\n","export const isObject = (value:any) => typeof value === 'object' && value?.toString() === '[object Object]';\n\nexport const sql = (template: TemplateStringsArray, ...args: any[]) => {\n  return template.map((t, i) => t + (args[i] ?? '')).join('')\n}\n\nexport const snakeToCamelCase = (str: string): string => {\n  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n}\n\nexport const camelToSnakeCase = (str: string): string => {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\n\nexport const convertRecordKeysToCamelCase = (obj: Record<string, any>, ignoreKeys: string[] = []): Record<string, any> => {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  if (Array.isArray(obj)) return obj.map(o => convertRecordKeysToCamelCase(o, ignoreKeys));\n  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [\n    ignoreKeys.includes(key) ? key : snakeToCamelCase(key),\n    value?.toString() === '[object Object]' ? convertRecordKeysToCamelCase(value, ignoreKeys) : value\n  ]));\n}\n\nexport const convertRecordKeysToSnakeCase = (obj: Record<string, any>, ignoreKeys: string[] = []): Record<string, any> => {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  if (Array.isArray(obj)) return obj.map(o => convertRecordKeysToSnakeCase(o, ignoreKeys));\n  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [\n    ignoreKeys.includes(key) ? key : camelToSnakeCase(key),\n    value?.toString() === '[object Object]' ? convertRecordKeysToSnakeCase(value, ignoreKeys) : value\n  ]));\n}\n\nexport const mergeDeep = (target: any, source: any) => {\n  const output = { ...target };\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] });\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n  return output;\n}\n\nexport const getUrl = (...paths: string[]) => {\n  const url = paths\n  .map(\n    p => p.trim()\n  )\n  .filter(Boolean)\n  .map(p => (\n    p.startsWith('/') ? p.slice(1) : p\n  ))\n  .map(p => p.endsWith('/') ? p.slice(0, -1) : p)\n  .join('/');\n  return url.endsWith('/') ? url.slice(0,-1) : url;\n}","import { PgClient, PgClientParams } from \"./pg\";\nimport { sql } from \"../utils\";\nimport { PostgresSchemaMap, PostgresTableMap, SchemaMap, TableMap } from \"../schema\";\nimport * as dotenv from 'dotenv';\nimport { FieldSchema } from \"./types\";\n\ndotenv.config();\n\nclass SqrlClientError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class SqrlPgClient extends PgClient {\n  connected = false;\n  constructor(params: PgClientParams) {\n    super(params);\n  }\n\n  async connect(){\n    const result = await super.connect();\n    this.connected = true;\n    return result;\n  }\n\n  async listTables() : Promise<string[]> {\n    if (!this.connected) throw new SqrlClientError('Client not connected');\n    const result = await this.query(sql`\n      SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';\n    `);\n    return result.rows.map((row: any) => row.table_name);\n  }\n\n  async getSchema() {\n    if (!this.connected) throw new SqrlClientError('Client not connected');\n    const tables = await this.listTables();\n    const schemaObject:PostgresSchemaMap = new Map();\n    for (const table of tables) {\n      const result = await this.query(sql`\n        SELECT * FROM information_schema.columns\n        WHERE table_schema = 'public'\n        AND table_name = '${table}';\n      `);\n\n      if (result.rows.length !== 0){\n        const tableMap:PostgresTableMap = new Map();\n        result.rows.forEach((row) => {\n          tableMap.set(row.column_name, row as FieldSchema);\n        });\n        schemaObject.set(table, tableMap);\n      }\n    }\n    return schemaObject;\n  }\n}\n\nexport const createSqrlPgClient = (params: PgClientParams) => {\n  return new SqrlPgClient(params);\n}","import { CustomField, Field, FieldOptions } from \"../fields\";\n\nexport const fieldOptionsToSql = (options: FieldOptions<any,any>) : string => {\n  let statement = [];\n  statement.push(options.withTimezone ? 'WITH TIME ZONE' : '');\n  statement.push(options.nullable === false ? 'NOT NULL' : 'NULL');\n  statement.push(options.unique ? 'UNIQUE' : '');\n  statement.push(options.default ? `DEFAULT ${options.default}` : '');\n  statement.push(options.generatedAlwaysAsIdentity ? 'GENERATED ALWAYS AS IDENTITY' : '');\n  statement.push(options.generatedByDefaultAsIdentity ? 'GENERATED BY DEFAULT AS IDENTITY' : '');\n  statement.push(options.primaryKey ? 'PRIMARY KEY' : '');\n  statement.push(options.references ? `REFERENCES ${options.references}` : '');\n\n  if (statement.includes('PRIMARY KEY') || statement.includes(`REFERENCES ${options.references}`)) {\n    statement = statement.filter(s => s !== 'NULL' && s !== 'NOT NULL');\n  }\n\n  return statement.filter(Boolean).join(' ');\n}\n\nexport const fieldToSqlType = (field: Field<any,any> | CustomField<any>) : string => {\n  if (field.type === '$') {\n    return field.statement;\n  }\n  return `${field.type}${field.options?.array ? '[]' : ''}${field.argument ? `(${field.argument})` : ''} ${fieldOptionsToSql(field.options ?? {})}`;\n}","import { sql, Table } from \"../..\";\nimport { CustomField, Field } from \"../fields\";\nimport { fieldToSqlType } from \"./utils\";\n\nexport const createTableSql =  (name: string, table: Table) : string => {\n  const fields = Object.entries(table).map(([key, field]) => `${key} ${fieldToSqlType(field)}`);\n  return sql`CREATE TABLE ${name} (\\n\\t${fields.join(',\\n\\t')}\\n);`\n}\n\nexport const dropTableSql = (name: string) : string => {\n  return sql`DROP TABLE ${name};`;\n}\n\nexport const alterTableAddFieldSql = (tableName: string, fieldName: string, field: Field<any,any> | CustomField<any>) => {\n  return sql`ALTER TABLE ${tableName} ADD COLUMN ${fieldName} ${fieldToSqlType(field)};`;\n}\nexport const alterTableDropFieldSql = (tableName: string, fieldName: string) => {\n  return sql`ALTER TABLE ${tableName} DROP COLUMN ${fieldName};`;\n}\nexport const alterTableAlterFieldSql = (tableName: string, fieldName: string, field: Field<any,any>) : string[] => {\n  const statements = [\n    sql`ALTER TABLE ${tableName} ALTER COLUMN ${fieldName} SET DATA TYPE ${field.type}${field.argument ? `(${field.argument})` : ''};`,\n    field.options?.nullable === false ? sql`ALTER TABLE ${tableName} ALTER COLUMN ${fieldName} SET NOT NULL;` : sql`ALTER TABLE ${tableName} ALTER COLUMN ${fieldName} DROP NOT NULL;`,\n  ];\n  if (field.options?.default) {\n    statements.push(sql`ALTER TABLE ${tableName} ALTER COLUMN ${fieldName} SET DEFAULT ${field.options.default};`);\n  }\n  if (field.options?.unique) {\n    statements.push(sql`ALTER TABLE ${tableName} ADD CONSTRAINT unique_${fieldName} UNIQUE (${fieldName});`);\n  }\n  return statements;\n}","import { FieldSchema } from \"../../../pg/types\";\nimport { createTableSql, dropTableSql, alterTableAddFieldSql, alterTableDropFieldSql, alterTableAlterFieldSql } from \"../../codegen/table\";\nimport { Field, PostgresSchemaMap, PostgresTableMap, SchemaInput, SchemaMap } from \"../../types\";\nimport { SchemaChange, SchemaDeployerConfig } from \"./types\";\n\nexport const DEFAULT_CONFIG: SchemaDeployerConfig = {\n  autoDeploy: false,\n}\n\nexport const getSchemaChangeset = (newSchema: SchemaInput, currentSchema: PostgresSchemaMap) : SchemaChange[] => {\n  const changeSet:SchemaChange[] = [];\n  // CREATE\n  for (const table in newSchema) {\n    if (!currentSchema.has(table)) {\n      changeSet.push({\n        type: 'CREATE_TABLE',\n        name: table,\n        fields: newSchema[table],\n      });\n    }\n    else {\n      const currentTable = currentSchema.get(table)!;\n      const newTable = newSchema[table]!;\n      for (const [field] of currentTable.entries()) {\n        if (!(field in newTable)) {\n          changeSet.push({\n            type: 'DROP_COLUMN',\n            tableName: table,\n            name: field\n          });\n        }\n      }\n      for (const field in newTable){\n        if (!currentTable.has(field)){\n          changeSet.push({\n            type: 'ADD_COLUMN',\n            tableName: table,\n            name: field,\n            field: newTable[field]\n          })\n        } else if (newTable[field].type !== '$') {\n          changeSet.push({\n            type: 'ALTER_COLUMN',\n            tableName: table,\n            name: field,\n            field: newTable[field]\n          })\n        }\n      }\n    }\n  }\n  // DROP\n  for (const table in currentSchema) {\n    if (!(table in newSchema)) {\n      changeSet.push({\n        type: 'DROP_TABLE',\n        name: table\n      });\n    }\n  }\n  return changeSet;\n}\n\nexport const convertSchemaChangesetToSql = (changeset: SchemaChange[]) : string[] => {\n  const statements:string[] = [];\n  for (const change of changeset){\n    if (change.type === 'CREATE_TABLE'){\n      statements.push(createTableSql(change.name, change.fields));\n    }\n    else if (change.type === 'DROP_TABLE'){\n      statements.push(dropTableSql(change.name));\n    }\n    else if (change.type === 'ADD_COLUMN'){\n      statements.push(alterTableAddFieldSql(change.tableName, change.name, change.field));\n    }\n    else if (change.type === 'DROP_COLUMN'){\n      statements.push(alterTableDropFieldSql(change.tableName, change.name));\n    }\n    else if (change.type === 'ALTER_COLUMN'){\n      statements.push(...alterTableAlterFieldSql(change.tableName, change.name, change.field));\n    }\n  }\n  return statements;\n}","\nimport { generateSchemaSql, SchemaInput } from \"../../../schema\";\nimport { SqrlPgClient } from \"../../../pg\";\nimport { SchemaChange, SchemaDeployerConfig } from \"./types\";\nimport { getSchemaChangeset, DEFAULT_CONFIG, convertSchemaChangesetToSql } from \"./utils\";\nimport { QueryResult } from \"pg\";\n\nclass SchemaDeployer {\n  readonly client: SqrlPgClient;\n  constructor(private readonly schema: SchemaInput, private readonly config: SchemaDeployerConfig = DEFAULT_CONFIG) {\n    this.client = new SqrlPgClient(this.config.client);\n    if (this.config.autoDeploy) {\n      this.client.connect().then(() => {\n        this.deploy();\n      });\n    }\n  }\n\n  async initialize() {\n    if (!this.client.connected) await this.client.connect();\n    const schemaStrings = generateSchemaSql(this.schema, { dropExisting: true });\n    const results = [];\n    for (const statement of schemaStrings) {\n      const result = await this.client.query(statement);\n      results.push(result);\n    }\n    await this.client.end();\n    return results;\n  }\n\n  async getChangeSet() {\n    if (!this.client.connected) await this.client.connect();\n    const currentSchema = await this.client.getSchema();\n    const changeSet = getSchemaChangeset(this.schema, currentSchema);\n    return changeSet;\n  }\n\n  async deploy(_changeSet?: SchemaChange[]) {\n    if (!this.client.connected) await this.client.connect();\n    const changeSet = _changeSet ?? await this.getChangeSet();\n    const statements = convertSchemaChangesetToSql(changeSet);\n    const results:Map<string, QueryResult|Error> = new Map();\n    for (const statement of statements) {\n      try {\n        const result = await this.client.query(statement);\n        results.set(statement, result);\n      } catch (error) {\n        results.set(statement, error as Error);\n      }\n    }\n    await this.client.end();\n    return results;\n  }\n\n}\n\n/**\n * @description \n * Initialize the schema\n * # WARNING - This will drop all existing tables and recreate them\n */\nexport async function initializeSchema(...params: ConstructorParameters<typeof SchemaDeployer>) {\n  const deployer = new SchemaDeployer(...params);\n  try {\n    return await deployer.initialize();\n  }\n  catch (error){\n    console.error(error);\n    deployer.client.end();\n    process.exit(1);\n  }\n  finally {\n    deployer.client.end();\n  }\n}\n\n/**\n * @description \n * - Deploys the schema\n * - This method preserves existing tables and only adds/removes/updates columns\n */\nexport async function deploySchema(...params: ConstructorParameters<typeof SchemaDeployer>) {\n  const deployer = new SchemaDeployer(...params);\n  try {\n    return await deployer.deploy();\n  }\n  catch (error){\n    console.error(error);\n    deployer.client.end();\n    process.exit(1);\n  }\n}\n/*\n\nexport const initializeSchema = async (schema: SchemaInput, ...params: ConstructorParameters<typeof Client>) => {\n  const client = new Client(...params);\n  await client.connect();\n  const schemaStrings = constructSqlSchema(schema);\n  if (process.env.DEBUG === 'true') {\n    console.log(schemaStrings);\n  }\n  const results = [];\n  for (const statement of schemaStrings) {\n    const result = await client.query(statement);\n    results.push(result);\n  }\n  await client.end();\n  return results;\n}\n\nexport const readSchema = async (schema: SchemaInput, ...params: ConstructorParameters<typeof Client>) => {\n  const client = new Client(...params);\n  await client.connect();\n  for (const table of Object.keys(schema)) {\n    const result = await client.query(sql`\n      SELECT * FROM information_schema.columns\n      WHERE table_schema = 'public'\n      AND table_name = '${table}';\n    `);\n    console.log(result.rows);\n  }\n  await client.end();\n}\n\n*/\n\n","import { SchemaInput } from \"..\";\nimport { sql } from \"../../utils\";\nimport { SchemaToSqlConfig } from \"./types\";\nimport { createTableSql } from \"./table\";\n\nexport const generateSchemaSql = (schema: SchemaInput, config?: SchemaToSqlConfig) : string[] => {\n  return Object.entries(schema).map(([name, table]) => [\n    config?.dropExisting ? sql`DROP TABLE IF EXISTS ${name} CASCADE;` : '',\n    createTableSql(name, table)\n  ]).flat().filter(Boolean);\n}\n"],"mappings":"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","names":["sql","dotenv","config","config"]}