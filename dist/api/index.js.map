{"version":3,"sources":["../../src/api/types/types.ts","../../src/api/api.ts","../../src/pg/index.ts","../../src/pg/pg.ts","../../src/utils/utils.ts","../../src/pg/sqrl.ts","../../src/api/routes/default/get.ts","../../src/api/routes/default/post.ts","../../src/api/routes/default/all.ts","../../src/api/routes/default/patch.ts","../../src/api/routes/default/delete.ts","../../src/api/routes/utils.ts","../../src/api/middleware/caseConversion.ts","../../src/api/middleware/middleware.ts","../../src/api/utils.ts"],"sourcesContent":["import { PgClientParams } from \"../../pg\";\nimport { API } from \"../api\";\n\nexport const HTTP_METHODS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD', 'TRACE', 'CONNECT'] as const;\n\nexport type HTTPMethod = typeof HTTP_METHODS[number];\n\nexport type AllQuery = {\n  page?: number;\n  limit?: number;\n  filter?: string;\n}\n\nexport type FilterOperator = 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte' | 'in' | 'like' | 'ilike';\n\nexport type Filter<T> = (\n  {eq: T} |\n  {ne: T} |\n  {gt: T} |\n  {gte: T} |\n  {lt: T} |\n  {lte: T} |\n  {in: T[]} |\n  {like: T} |\n  {ilike: T}\n)\n\nexport type FilterParams<T> = Partial<{\n  [K in keyof T]: Filter<T[K]>\n}> | {\n  AND?: FilterParams<T>[];\n} | {\n  OR?: FilterParams<T>[];\n} | {\n  NOT?: FilterParams<T>;\n}\n\nexport type ListParams<T> = {\n  page?: number;\n  limit?: number;\n  filter?: FilterParams<T>;\n}\n\nexport type APIConfig = {\n  client?: PgClientParams;\n  /**\n   * @description The port to run the API on\n   */\n  port?: number;\n  /**\n   * @description The prefix to use for the API\n   * @example '/api'\n   * @default '/api'\n  */\n  prefix?: `/${string}`;\n  /**\n   * @description The case conversion to use for the API\n   * @example { in: 'snake', out: 'camel' }\n   */\n  caseConversion?: {\n    in: 'snake' | 'camel';\n    out: 'snake' | 'camel';\n  }\n  /**\n   * @description The pagination to use for the API\n   * @example { defaultPage: 1, defaultLimit: 10 }\n   */\n  pagination?: {\n    defaultPage?: number;\n    defaultLimit?: number;\n  }\n  /**\n   * @description The header to use for the API\n   * @example 'Authorization'\n   * @default 'Authorization'\n   */\n  tokenHeader?: string;\n}\n\nexport type APISchema<T extends API> = T extends API<infer S> ? S : never;\n\nexport type APIRoute<T extends API> = T extends API<infer S, infer E> ? (\n  keyof S extends string ? (keyof S | keyof ReturnType<E> | `${keyof S}/:id`) : never\n) : never\n\nexport type APIRoutes<T extends API> = APIRoute<T>[]\n\nexport type APIRouteMethods<T extends API> = T extends API<infer S, infer E> ? (\n  keyof S extends string ? {\n    [key in (keyof S | keyof ReturnType<E> | `${keyof S}/:id`)]: {\n      GET: (keyof (S[keyof S]))[];\n      POST: keyof (S[keyof S]);\n      PUT: keyof (S[keyof S]);\n      PATCH: keyof (S[keyof S]);\n      DELETE: keyof (S[keyof S]);\n    }\n  } : never\n) : never;\n","import express, {Request, RequestHandler} from 'express';\nimport { SchemaInput } from '../schema';\nimport { APIConfig, ApiExtensionFunction, APIRoutes, APIRouteMethods, APIRoute, HTTPMethod, HTTP_METHODS } from './types';\nimport { PgClient } from '../pg';\nimport { createDefaultRoutes } from './routes/utils';\nimport * as dotenv from 'dotenv';\nimport { caseConversionMiddleware } from './middleware';\nimport { mergeDeep } from '../utils';\nimport { getFullPath as getPath } from './utils';\nimport { createJsonMiddleware, JsonMiddleware } from './middleware/middleware';\n\ndotenv.config();\n\nconst DEFAULT_CONFIG: APIConfig = {\n  port: 3000,\n  prefix: '/api',\n  pagination: {\n    defaultPage: 1,\n    defaultLimit: 10,\n  }\n}\n\n/**\n * ---\n * @see {@link createApi}\n * ---\n */\nexport class API<Schema extends SchemaInput = any, ExtensionFn extends ApiExtensionFunction = ApiExtensionFunction> {\n  readonly app: express.Application;\n  readonly client: InstanceType<typeof PgClient>;\n  config: APIConfig = DEFAULT_CONFIG;\n  readonly extensionFn: ExtensionFn;\n  constructor(readonly schema: Schema, extensionFn: ExtensionFn, config: APIConfig = DEFAULT_CONFIG) {\n    this.config = mergeDeep(DEFAULT_CONFIG, config);\n    const app = express();\n    app.use(express.json());\n    app.use(express.urlencoded({ extended: true }));\n    this.app = app;\n    this.client = new PgClient(config.client);\n    this.extensionFn = extensionFn;\n  }\n\n  private initDefaultRoutes() {\n    Object.entries(this.schema).forEach(([name, table]) => {\n      createDefaultRoutes(this, name, table);\n    });\n  }\n\n  private initExtensions() {\n    const extensions = this.extensionFn(this);\n    Object.entries(extensions).forEach(([name, methods]) => {\n      const {get, post, patch, delete: del, put} = methods;\n      if (get) {\n        this.app.get(getPath(name, this.config.prefix), get);\n      }\n      if (post) {\n        this.app.post(getPath(name, this.config.prefix), post);\n      }\n      if (patch) {\n        this.app.patch(getPath(name, this.config.prefix), patch);\n      }\n      if (del) {\n        this.app.delete(getPath(name, this.config.prefix), del);\n      }\n      if (put) {\n        this.app.put(getPath(name, this.config.prefix), put);\n      }\n    });\n  }\n\n  private initMiddleware() {\n    if (this.config.caseConversion) {\n      const inCase = this.config.caseConversion?.in;\n      const outCase = this.config.caseConversion?.out;\n      this.app.use(caseConversionMiddleware({inCase, outCase}));\n    }\n  }\n\n  private initialize() {\n    this.initMiddleware();\n    this.initExtensions();\n    this.initDefaultRoutes();\n  }\n\n  /**\n   * @description \n   * - Create a function that checks if the request matches the route and method.\n   * - Useful for middleware.\n   * @example\n   * ```typescript\n   * const isOp = api.createOpChecker(req);\n   * \n   * if (isOp('users/:id', 'GET')) {\n   *   // Do something\n   * }\n   * ```\n   */\n  createOpChecker(req:Request) {\n    return (\n      route: Parameters<typeof this.isOp>[1],\n      method: Parameters<typeof this.isOp>[2] = [...HTTP_METHODS]\n    ) => this.isOp(req, route, method);\n  }\n\n  /**\n   * @description \n   * - Check if the request matches the route and method.\n   * - Useful for middleware.\n   * @example\n   * ```typescript\n   * api.isOp(req, 'users', 'GET');\n   * ```\n   */\n  isOp(req: Request, route: APIRoute<this>[] | APIRoute<this>, method:HTTPMethod | HTTPMethod[] = [...HTTP_METHODS]) {\n    const routes = Array.isArray(route) ? route : [route];\n    const methods = Array.isArray(method) ? method : [method];\n    const {method: reqMethod, route: reqRoute} = this.describeRequest(req);\n    return routes.some((r) => r === reqRoute) && methods.some((m) => m === reqMethod);\n  }\n\n  /**\n   * @description Configure the API\n   * @example\n   * ```typescript\n   * api.configure({port: 3001});\n   * ```\n   */\n  configure(config: APIConfig) {\n    const mergedConfig = mergeDeep(this.config, config);\n    this.config = mergedConfig;\n  }\n\n  /**\n   * @description Check if the API has a route\n   * @example\n   * ```typescript\n   * api.hasRoute('/users');\n   * ```\n   */\n  hasRoute(path: string) {\n    return this.app._router.stack.some((route: any) => route.route?.path === path);\n  }\n\n  /**\n   * @description Remove the API's prefix from a path\n   * @example\n   * ```typescript\n   * api.relpath(req);\n   * // '/api/users' --> 'users'\n   * ```\n   */\n  relpath(path: string | Request) {\n    let newPath:string;\n    if (typeof path === 'string') {\n      newPath = path.replace(this.config.prefix ?? '', '');\n    }\n    else {\n      newPath = path.path.replace(this.config.prefix ?? '', '');\n    }\n    return newPath.startsWith('/') ? newPath.slice(1) : newPath;\n  }\n\n  /**\n   * @description Describe the operation of a request\n   * @example\n   * ```typescript\n   * const {path, method} =api.describeReqOp(req);\n   * ```\n   */\n  describeRequest(req: Request) {\n    let route:string | undefined = undefined;\n    const match = this.app._router.stack.find((layer: any) =>\n      layer.route && layer.route.path && req.path.match(layer.regexp)\n    );\n    if (match) {\n      route = this.relpath(match.route.path); // \"/users/:id\"\n    }\n    const path = this.relpath(req);\n    const method = req.method;\n    return {path, method, route};\n  }\n\n  /**\n   * @description Add a middleware to the API that will help authorize requests\n   * @returns ```ts\n    type Return = (\n        // Return a status code and a function that will be called with the body of the response\n        [statusCode: number, bodyFunction: (body: any) => any] |\n        // Return a function that will be called with the body of the response\n        (body: any) => any\n    )\n   * ```\n   * @example\n   * ```typescript\n    api.auth(client => async (req, res, next) => {\n      const unauthorized = () => [401, () => ({error: 'Unauthorized'})];\n      const isOp = api.createOpChecker(req);\n      const token = req.headers['authorization'];\n      const {path} = api.describeRequest(req)\n      // Do not use a users email as your auth token, just an example\n      const user: Schema['users'] = await client.query('select * from users where email = $1', [token]).then(({rows}) => rows[0]);\n      if (!user) return unauthorized();\n      if (isOp('users/:id', 'GET')) {\n        if (user.id.toString() !== path.split('/').pop())\n          return unauthorized();\n      }\n    });\n   * ```\n   */\n  auth(handlerOne: (client: InstanceType<typeof PgClient>) => JsonMiddleware) {\n    const handler = handlerOne(this.client);\n    this.app.use(\n      createJsonMiddleware(async function (req, res, next) {\n        return await handler(req, res, next);\n      })\n    );\n  }\n\n  /**\n   * @description Start the API Server\n   * @example\n   * ```typescript\n   * api.start().then((err) => {\n   *   if (err) {\n   *     console.error(err);\n   *   }\n   *   else {\n   *     console.log(`API is running on port ${api.config.port}`);\n   *   }\n   * });\n   * ```\n   */\n  async start(): Promise<Error | undefined> {\n    await this.client.connect();\n    this.initialize();\n    return new Promise((resolve, reject) => {\n      this.app.listen(this.config.port, (...args) => {\n        resolve(...args);\n      });\n    });\n  }\n}\n\n/**\n * @description Create a new API instance\n * @example \n * Define an API\n * ```typescript\n  import { schema, type Schema } from \"./schema\";\n  import { createApi, handler as $ } from \"../src/api\";\n\n  const api = createApi(\n    schema,\n    ({client}) => ({\n      // *note* The keys of the record must not start with a slash\n      'example-users': {\n        get: $<Schema['users'][]>(async (req, res) => {\n          const users = await client.query('SELECT * FROM users WHERE email ilike $1', [`%example.com%`]);\n          res.status(200).json(users.rows);\n        }),\n        post: $<Schema['users'], Schema['users']>(async (req, res) => {\n          const user = await client.query('select * from users where id = 2');\n          res.status(200).json(user.rows[0]);\n        })\n      }\n    }),\n    {\n      caseConversion: {\n        in: 'snake',\n        out: 'camel',\n      },\n      pagination: {\n        defaultPage: 1,\n        defaultLimit: 10,\n      }\n    }\n  );\n\n  export default api;\n  * ```\n  * @example\n  * Start the API\n  * ```typescript\n    import api from './api';\n\n    api.start().then((err) => {\n      if (err) {\n        console.error(err);\n      }\n      else {\n        console.log(`API is running on port ${api.config.port}`);\n      }\n    });\n  * ```\n */\nexport const createApi = <Schema extends SchemaInput, ExtensionFn extends ApiExtensionFunction>(schema: Schema, extensionFn: ExtensionFn, config: APIConfig = DEFAULT_CONFIG) => {\n  return new API<Schema, ExtensionFn>(schema, extensionFn, config);\n}","import * as dotenv from 'dotenv';\n\ndotenv.config();\n\nexport * from './pg';\nexport * from './sqrl';","// import { Client as PgClient } from \"pg\";\nimport pg from 'pg';\n\nexport const PgClient = pg.Client;\n\nexport type PgClientParams = ConstructorParameters<typeof PgClient>[0];\n\n/**\n * \n * @param params \n * ```typescript\n * string | {\n *   user?: string, // default process.env.PGUSER || process.env.USER\n *   password?: string or function, //default process.env.PGPASSWORD\n *   host?: string, // default process.env.PGHOST\n *   port?: number, // default process.env.PGPORT\n *   database?: string, // default process.env.PGDATABASE || user\n *   connectionString?: string, // e.g. postgres://user:password@host:5432/database\n *   ssl?: any, // passed directly to node.TLSSocket, supports all tls.connect options\n *   types?: any, // custom type parsers\n *   statement_timeout?: number, // number of milliseconds before a statement in query will time out, default is no timeout\n *   query_timeout?: number, // number of milliseconds before a query call will timeout, default is no timeout\n *   lock_timeout?: number, // number of milliseconds a query is allowed to be en lock state before it's cancelled due to lock timeout\n *   application_name?: string, // The name of the application that created this Client instance\n *   connectionTimeoutMillis?: number, // number of milliseconds to wait for connection, default is no timeout\n *   idle_in_transaction_session_timeout?: number // number of milliseconds before terminating any session with an open idle transaction, default is no timeout\n * }\n * ```\n * @returns \n */\nexport const createPgClient = (params: PgClientParams) => {\n  return new PgClient(params);\n}\n\n/**\n * \n * @param params \n * ```typescript\n * {\n *   user?: string, // default process.env.PGUSER || process.env.USER\n *   password?: string or function, //default process.env.PGPASSWORD\n *   host?: string, // default process.env.PGHOST\n *   port?: number, // default process.env.PGPORT\n *   database?: string, // default process.env.PGDATABASE || user\n *   connectionString?: string, // e.g. postgres://user:password@host:5432/database\n *   ssl?: any, // passed directly to node.TLSSocket, supports all tls.connect options\n *   types?: any, // custom type parsers\n *   statement_timeout?: number, // number of milliseconds before a statement in query will time out, default is no timeout\n *   query_timeout?: number, // number of milliseconds before a query call will timeout, default is no timeout\n *   lock_timeout?: number, // number of milliseconds a query is allowed to be en lock state before it's cancelled due to lock timeout\n *   application_name?: string, // The name of the application that created this Client instance\n *   connectionTimeoutMillis?: number, // number of milliseconds to wait for connection, default is no timeout\n *   idle_in_transaction_session_timeout?: number // number of milliseconds before terminating any session with an open idle transaction, default is no timeout\n * }\n * ```\n * @returns \n */\nexport const createConnectedPgClient = async (params: ConstructorParameters<typeof PgClient>[0]) => {\n  const client = createPgClient(params);\n  await client.connect();\n  return client;\n}\n","export const isObject = (value:any) => typeof value === 'object' && value?.toString() === '[object Object]';\n\nexport const sql = (template: TemplateStringsArray, ...args: any[]) => {\n  return template.map((t, i) => t + (args[i] ?? '')).join('')\n}\n\nexport const snakeToCamelCase = (str: string): string => {\n  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n}\n\nexport const camelToSnakeCase = (str: string): string => {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\n\nexport const convertRecordKeysToCamelCase = (obj: Record<string, any>, ignoreKeys: string[] = []): Record<string, any> => {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  if (Array.isArray(obj)) return obj.map(o => convertRecordKeysToCamelCase(o, ignoreKeys));\n  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [\n    ignoreKeys.includes(key) ? key : snakeToCamelCase(key),\n    value?.toString() === '[object Object]' ? convertRecordKeysToCamelCase(value, ignoreKeys) : value\n  ]));\n}\n\nexport const convertRecordKeysToSnakeCase = (obj: Record<string, any>, ignoreKeys: string[] = []): Record<string, any> => {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  if (Array.isArray(obj)) return obj.map(o => convertRecordKeysToSnakeCase(o, ignoreKeys));\n  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [\n    ignoreKeys.includes(key) ? key : camelToSnakeCase(key),\n    value?.toString() === '[object Object]' ? convertRecordKeysToSnakeCase(value, ignoreKeys) : value\n  ]));\n}\n\nexport const mergeDeep = (target: any, source: any) => {\n  const output = { ...target };\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] });\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n  return output;\n}\n\nexport const getUrl = (...paths: string[]) => {\n  const url = paths\n  .map(\n    p => p.trim()\n  )\n  .filter(Boolean)\n  .map(p => (\n    p.startsWith('/') ? p.slice(1) : p\n  ))\n  .map(p => p.endsWith('/') ? p.slice(0, -1) : p)\n  .join('/');\n  return url.endsWith('/') ? url.slice(0,-1) : url;\n}","import { PgClient, PgClientParams } from \"./pg\";\nimport { sql } from \"../utils\";\nimport { PostgresSchemaMap, PostgresTableMap, SchemaMap, TableMap } from \"../schema\";\nimport * as dotenv from 'dotenv';\nimport { FieldSchema } from \"./types\";\n\ndotenv.config();\n\nclass SqrlClientError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class SqrlPgClient extends PgClient {\n  connected = false;\n  constructor(params: PgClientParams) {\n    super(params);\n  }\n\n  async connect(){\n    const result = await super.connect();\n    this.connected = true;\n    return result;\n  }\n\n  async listTables() : Promise<string[]> {\n    if (!this.connected) throw new SqrlClientError('Client not connected');\n    const result = await this.query(sql`\n      SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';\n    `);\n    return result.rows.map((row: any) => row.table_name);\n  }\n\n  async getSchema() {\n    if (!this.connected) throw new SqrlClientError('Client not connected');\n    const tables = await this.listTables();\n    const schemaObject:PostgresSchemaMap = new Map();\n    for (const table of tables) {\n      const result = await this.query(sql`\n        SELECT * FROM information_schema.columns\n        WHERE table_schema = 'public'\n        AND table_name = '${table}';\n      `);\n\n      if (result.rows.length !== 0){\n        const tableMap:PostgresTableMap = new Map();\n        result.rows.forEach((row) => {\n          tableMap.set(row.column_name, row as FieldSchema);\n        });\n        schemaObject.set(table, tableMap);\n      }\n    }\n    return schemaObject;\n  }\n}\n\nexport const createSqrlPgClient = (params: PgClientParams) => {\n  return new SqrlPgClient(params);\n}","import { Table } from '../../../schema';\nimport { API } from '../../api';\nimport { sql } from '../../../utils';\n\nexport function createGetRoute(api: API, name: string, table: Table) {\n  const columns = Object.keys(table).join(', ');\n  const route = `${api.config.prefix}/${name}/:id`;\n  if (!api.hasRoute(route))\n    api.app.get(route, async (req, res) => {\n      try {\n        const statement = (\n          sql`\n          SELECT ${columns} FROM ${name}\n          WHERE id = $1;\n        `\n        );\n        const values = [req.params.id];\n        const result = await api.client.query(statement, values);\n        if (!result.rows[0]) {\n          res.status(404).send({ error: `Resource not found` });\n        }\n        else {\n          res.status(200).send(result.rows[0]);\n        }\n      }\n      catch (err) {\n        console.log(err);\n        res.status(500).send({ error: err });\n      }\n    });\n}","import { Table } from '../../../schema';\nimport { API } from '../../api';\nimport { sql } from '../../../utils';\n\nexport const createPostRoute = (api:API, name: string, table: Table) => {\n  const route = `${api.config.prefix}/${name}`;\n  if (!api.hasRoute(route)) api.app.post(route, async (req, res) => {\n    try {\n      let iterator = 1;\n      const columns = Object.keys(req.body);\n      const values = Object.values(req.body);\n      const valuesParams = values.map(() => `$${iterator++}`).join(', ');\n      let statement = sql`\n        INSERT INTO ${name} (${columns.join(', ')})\n        VALUES (${valuesParams})\n        RETURNING *;\n      `;\n      const result = await api.client.query(statement, values);\n      res.status(201).json(result.rows[0]);\n    }\n    catch (err) {\n      console.log(err);\n      res.status(500).json(err);\n    }\n  });\n}","import { Table } from '../../../schema';\nimport { API } from '../../api';\nimport { convertRecordKeysToSnakeCase, sql } from '../../../utils';\nimport { AllQuery, FilterOperator, FilterParams } from '../../types';\n\ntype FilterStatementMap = Record<FilterOperator, (field: string, value: any, index: number) => { statment: string, values: any[] }>;\n\nconst filterStatementMap: FilterStatementMap = {\n  eq: (field: string, value: any, index: number) => {\n    return { statment: `${field} = $${index}`, values: [value] };\n  },\n  ne: (field: string, value: any, index: number) => {\n    return { statment: `${field} != $${index}`, values: [value] };\n  },\n  gt: (field: string, value: any, index: number) => {\n    return { statment: `${field} > $${index}`, values: [value] };\n  },\n  gte: (field: string, value: any, index: number) => {\n    return { statment: `${field} >= $${index}`, values: [value] };\n  },\n  lt: (field: string, value: any, index: number) => {\n    return { statment: `${field} < $${index}`, values: [value] };\n  },\n  lte: (field: string, value: any, index: number) => {\n    return { statment: `${field} <= $${index}`, values: [value] };\n  },\n  in: (field: string, value: any[], index: number) => {\n    return { statment: `${field} IN (${value.map((v, i) => sql`$${index + i}`).join(',')})`, values: value };\n  },\n  like: (field: string, value: any, index: number) => {\n    return { statment: `${field} LIKE $${index}`, values: [`%${value}%`] };\n  },\n  ilike: (field: string, value: any, index: number) => {\n    return { statment: `${field} ILIKE $${index}`, values: [`%${value}%`] };\n  },\n}\n\nconst getFilterStatements = (filter: FilterParams<Record<string, string>>, index: number = 3): { statments: string[], values: any[] } => {\n  const statementArray: string[] = [];\n  const statementValues: any[] = [];\n  filter = convertRecordKeysToSnakeCase(filter, ['AND', 'OR', 'NOT']);\n  for (const [key, value] of Object.entries(filter)) {\n    if (key.toUpperCase() === 'AND' || key.toUpperCase() === 'OR') {\n      const subStatements: string[] = [];\n      for (const v of value) {\n        const { statments, values } = getFilterStatements(v, index);\n        subStatements.push(...statments);\n        statementValues.push(...values);\n        index += values.length;\n      }\n      const statement = `(${subStatements.join(` ${key.toUpperCase()} `)})`;\n      statementArray.push(statement);\n    }\n    else if (key.toUpperCase() === 'NOT') {\n      const { statments, values } = getFilterStatements(value, index);\n      statementArray.push(`NOT ${statments.join(' ')}`);\n      statementValues.push(...values);\n    }\n    else {\n      for (const op in value) {\n        const { statment, values } = filterStatementMap[op as FilterOperator](key, value[op], index);\n        statementArray.push(statment);\n        statementValues.push(...values);\n        index += values.length;\n      }\n    }\n  }\n  return { statments: statementArray, values: statementValues };\n}\n\nexport const createAllRoute = (api: API, name: string, table: Table) => {\n  const columns = Object.keys(table).join(', ');\n  const route = `${api.config.prefix}/${name}`;\n  if (!api.hasRoute(route))\n    api.app.get(route, async (req, res) => {\n      try {\n        const { page = api.config.pagination?.defaultPage ?? 1, limit = api.config.pagination?.defaultLimit ?? 10, filter = '{}' } = req.query as AllQuery;\n        const filterObject = JSON.parse(filter) as FilterParams<Record<string, string>>;\n        const { statments, values: statementValues } = getFilterStatements(filterObject);\n        const statement = [\n          sql`SELECT ${columns} FROM ${name}`,\n          ...statments.length > 0 ? [sql`WHERE ${statments.join(' AND ')}`] : [],\n          sql`LIMIT $1 OFFSET $2`,\n        ].join(' ');\n        const values = [limit, (page - 1) * limit, ...statementValues];\n        const result = await api.client.query(statement, values);\n        res.status(200).json(result.rows);\n      }\n      catch (err) {\n        console.error(err);\n        res.status(500).json(err);\n      }\n    });\n}\n","import { Table } from '../../../schema';\nimport { API } from '../../api';\nimport { sql } from '../../../utils';\n\nexport const createPatchRoute = (api:API, name: string, table: Table) => {\n  const route = `${api.config.prefix}/${name}/:id`;\n  if (!api.hasRoute(route)) api.app.patch(route, async (req, res) => {\n    try {\n      let iterator = 2;\n      const id = req.params.id;\n      const setStatment = Object.keys(req.body).map((key) => `${key} = $${iterator++}`).join(', ');\n      const values = Object.values(req.body);\n      const statement = sql`\n        UPDATE ${name} SET ${setStatment} WHERE id = $1;\n        RETURNING *;\n      `;\n      const result = await api.client.query(statement, [id, ...values]);\n      res.status(200).json(result.rows[0]);\n    }\n    catch (err) {\n      console.log(err);\n      res.status(500).json(err);\n    }\n  });\n}","import { Table } from '../../../schema';\nimport { API } from '../../api';\nimport { sql } from '../../../utils';\n\nexport const createDeleteRoute = (api:API, name: string, table: Table) => {\n  const route = `${api.config.prefix}/${name}/:id`;\n  if (!api.hasRoute(route)) api.app.delete(route, async (req, res) => {\n    try {\n      const id = req.params.id;\n      const statement = sql`\n        DELETE FROM ${name}\n        WHERE id = $1\n        RETURNING *;\n      `;\n      const result = await api.client.query(statement, [id]);\n      const rows = result.rows;\n      if (!rows[0]) {\n        res.status(404).json({error: `Resource not found`});\n      }\n      else {\n        res.status(200).json(rows[0]);\n      }\n    }\n    catch (err) {\n      console.log(err);\n      res.status(500).json(err);\n    }\n  });\n}","\nimport { Table } from '../../schema';\nimport { API } from '../api';\nimport { createAllRoute, createGetRoute, createPostRoute, createPatchRoute, createDeleteRoute } from './';\nimport { ApiExtensionRecord } from '../types/extensions';\nimport { RequestHandler } from 'express';\n\nexport const createDefaultRoutes = (api:API, name: string, table: Table) => {\n  createAllRoute(api, name, table);\n  createGetRoute(api, name, table);\n  createPostRoute(api, name, table);\n  createPatchRoute(api, name, table);\n  createDeleteRoute(api, name, table);\n}\n\n/**\n * @example\n * ```typescript\n  import { handler as $, createRoutes } from \"../routes/utils\";\n\n  const routes = createRoutes({\n    'fish': {\n      get: $<{a:1}>(async (req, res) => {\n        res.status(200).json({\n          a: 1\n        });\n      })\n    },\n    'fish/trout': {\n      get: $<{a:1}>(async (req, res) => {\n        res.status(200).json({\n          a: 1\n        });\n      })\n    },\n    'goblin': {\n      post: $<{a:1}>(async (req, res) => {\n        res.status(200).json({\n          a: 1\n        });\n      })\n    },\n    'goblin/potter': {\n      get: $<{a:1}>(async (req, res) => {\n        res.status(200).json({\n          a: 1\n        });\n      })\n    }\n  });\n  * ```\n*/\nexport const createRoutes = <T extends ApiExtensionRecord>(ext: T) => <const>{...ext};\nexport const handler = <Output,Input = undefined>(reqFn:RequestHandler<any, Output, Input>) => reqFn;","import { RequestHandler } from \"express\";\nimport { convertRecordKeysToSnakeCase } from \"../../utils/utils\";\nimport { convertRecordKeysToCamelCase } from \"../../utils/utils\";\n\nexport const caseConversionMiddleware = ({inCase, outCase}: {inCase: 'snake' | 'camel', outCase: 'snake' | 'camel'}): RequestHandler => {\n  return function (req, res, next){\n    if (inCase === 'snake') {\n      req.body = convertRecordKeysToSnakeCase(req.body);\n    }\n    else if (inCase === 'camel') {\n      req.body = convertRecordKeysToCamelCase(req.body);\n    }\n    const json = res.json;\n    res.json = (body: any) => {\n      return json.call(res, outCase === 'camel' ? convertRecordKeysToCamelCase(body) : convertRecordKeysToSnakeCase(body));\n    }\n    next();\n  }\n}","import { RequestHandler } from \"express\";\n\ntype RequestHandlerParams = Parameters<RequestHandler>;\ntype JsonMiddlewareReturn = ((body: any) => any) | [statusCode: number, bodyFn: ((body: any) => any)] | Readonly<[statusCode: number, bodyFn: ((body: any) => any)]> | void;\nexport type JsonMiddleware = (...args: RequestHandlerParams) => JsonMiddlewareReturn | Promise<JsonMiddlewareReturn>;\n\n/**\n * @example\n * ```ts\n * \n  createJsonMiddleware((req, res) => {\n    req.body = req.body;\n    return (body) => ({\n      ...body,\n      fish: 'goose'\n    })\n  }) \n * ```\n*/ \nexport const createJsonMiddleware = (handler: JsonMiddleware) : RequestHandler => {\n  return async function (req, res, next){\n    const jsonHandler = await handler(req, res, next);\n    const json = res.json;\n    const status = res.status;\n    if (typeof jsonHandler === 'function') {\n      res.json = (body: any) => {\n        return json.call(res, (jsonHandler as ((body: any) => any))(body));\n      }\n    }\n    else if (Array.isArray(jsonHandler)) {\n      const [statusCode, bodyFn] = jsonHandler;\n      res.json = (body: any) => {\n        return json.call(res, bodyFn ? bodyFn(body) : body);\n      }\n      res.status = (_: number) => {\n        return status.call(res, statusCode);\n      }\n    }\n    next();\n  }\n}\n","export {createRoutes, handler} from './routes/utils';\n\nexport const getFullPath = (path: string, prefix: string = '/api') => {\n  return `${prefix}${path.startsWith('/') ? '' : '/'}${path}`;\n}"],"mappings":"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","names":["dotenv","dotenv","handler","config","handler"]}