{"version":3,"sources":["../src/index.ts","../src/utils/utils.ts"],"sourcesContent":["export type * from './schema';\nexport {sql} from './utils';\n","export const isObject = (value:any) => typeof value === 'object' && value?.toString() === '[object Object]';\n\nexport const sql = (template: TemplateStringsArray, ...args: any[]) => {\n  return template.map((t, i) => t + (args[i] ?? '')).join('')\n}\n\nexport const snakeToCamelCase = (str: string): string => {\n  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n}\n\nexport const camelToSnakeCase = (str: string): string => {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\n\nexport const convertRecordKeysToCamelCase = (obj: Record<string, any>, ignoreKeys: string[] = []): Record<string, any> => {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  if (Array.isArray(obj)) return obj.map(o => convertRecordKeysToCamelCase(o, ignoreKeys));\n  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [\n    ignoreKeys.includes(key) ? key : snakeToCamelCase(key),\n    value?.toString() === '[object Object]' ? convertRecordKeysToCamelCase(value, ignoreKeys) : value\n  ]));\n}\n\nexport const convertRecordKeysToSnakeCase = (obj: Record<string, any>, ignoreKeys: string[] = []): Record<string, any> => {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  if (Array.isArray(obj)) return obj.map(o => convertRecordKeysToSnakeCase(o, ignoreKeys));\n  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [\n    ignoreKeys.includes(key) ? key : camelToSnakeCase(key),\n    value?.toString() === '[object Object]' ? convertRecordKeysToSnakeCase(value, ignoreKeys) : value\n  ]));\n}\n\nexport const mergeDeep = (target: any, source: any) => {\n  const output = { ...target };\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] });\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n  return output;\n}\n\nexport const getUrl = (...paths: string[]) => {\n  const url = paths\n  .map(\n    p => p.trim()\n  )\n  .filter(Boolean)\n  .map(p => (\n    p.startsWith('/') ? p.slice(1) : p\n  ))\n  .map(p => p.endsWith('/') ? p.slice(0, -1) : p)\n  .join('/');\n  return url.endsWith('/') ? url.slice(0,-1) : url;\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEO,IAAM,MAAM,CAAC,aAAmC,SAAgB;AACrE,SAAO,SAAS,IAAI,CAAC,GAAG,MAAM,KAAK,KAAK,CAAC,KAAK,GAAG,EAAE,KAAK,EAAE;AAC5D;","names":[]}